"""
    Given a timeserie in input, generate a new, randomly picked,
    timeserie with the same values as the input timeserie, with an anomaly.
    The anomaly is generated by taking the highest values of the timeserie.
    Two types of anomalies:
        - Regime shift: use highest value, shuffled, to do a regime shift
                        at an index randomly picked idx. At idx, the mean
                        of the timeserie changes to a higher value.
        - Peak:         use a small number of the highest value, shuffled,
                        to create a peak randomly place in the timeserie.
    The complete process is:

    >>> - read input timeserie TS
    >>> - sort TS in increasing order
    >>> - Define index an_i such that the anomaly will contain the values
    >>>   of TS after an_i (highest values)
    >>> - shuffle TS[an_i:] to get 'anomaly'
    >>> - shuffle TS[:an_i] to get 'normality'
    >>> - if anomaly_type is peak:
    >>>     - pick random position pos < an_i
    >>>     - create TS` new timeserie with anomaly at pos such that:
    >>>        -TS`[pos:pos + (anomaly_duration)] = TS[an_i:]
    >>>        -TS`[:pos] + TS'[pos+(anomaly_duration):] = TS[:an_i] 
    >>>         (where + designates the concatenation of arrays)
"""
import os
import time
import numpy as np
import matplotlib.pyplot as plt

from GTgen.timeserie import * 

class DataTimeserie():
    """
         Attributes:
         -----------
         value_list: list of int,
            the timeserie taken as input
         anomaly_type: string, either 'regimeShift' or 'peak',
            if regimeShift, anomaly is a regimeShift, otherwise it is a peak
         anomaly_duration: float,
            the duration of the anomaly is anomaly_duration * len(value_list),
         output: string,
            path to the output file in which timeserie should be written
         logger: logger,
            a logger
         plot: bool,
            if True, plot the timeserie
    """
    def __init__(self, value_list,
            anomaly_type,
            anomaly_duration,
            norm_weight_sum,
            an_weight_sum,
            output,
            logger,
            plot=False):
        #self.numberOfAnomaly = numberofAnomaly
        self.value_list = value_list
        self.anomaly_type = anomaly_type
        self.anomaly_duration = int(len(value_list) * anomaly_duration)
        self.anomaly_index = None

        # constrain the anomaly
        self.norm_weight_sum = norm_weight_sum
        self.an_weight_sum = an_weight_sum

        self.timeserie = Timeserie(serie=np.array(value_list, dtype=np.int32), out_path=os.path.join(output,'normal_serie.txt'))
        self.an_timeserie = Timeserie(serie=np.zeros(self.timeserie.serie.shape, dtype=np.int32), out_path=os.path.join(output, 'anomaly_serie.txt'))

        # sort timeserie
        self.timeserie.serie = self.timeserie.sorted_timeserie
        self.logger = logger
        self.output = output
        self.plot = plot

    #def _generate_anomaly(self):
    #    """ To generate an anomaly, take the value_list sorted, 
    #    pick random values for anomaly serie with the last 
    #    anomaly_duration * len(value_list) as upper bound, and substract these
    #    values to the normal serie.
    #    """

    #    # anomaly_duration is a ratio
    #    self.anomaly_index = self.timeserie.duration - self.anomaly_duration
    #    anomaly_indexes = list(range(self.anomaly_index, self.timeserie.duration))

    #    # randomly pick values for anomaly
    #    for value_index in anomaly_indexes:
    #        an_value = np.random.choice(self.timeserie.serie[value_index])
    #        self.an_timeserie.serie[value_index] = an_value
    #        self.timeserie.serie[value_index] -= an_value

    #    # shuffle remaining for "normality"
    #    self.timeserie.shuffle_timeserie(
    #            index_low = 0, index_high = self.anomaly_index)

    #    # generate regime shift by shuffling highest values
    #    np.random.shuffle(anomaly_indexes)
    #    self.timeserie.serie[self.anomaly_index:] = self.timeserie.serie[anomaly_indexes]
    #    self.an_timeserie.serie[self.anomaly_index:] = self.an_timeserie.serie[anomaly_indexes]

    #    #self.timeserie.shuffle_timeserie(
    #    #        index_low = self.anomaly_index, index_high = None)

    def _generate_anomaly(self):
        """ To generate an anomaly, take the value_list sorted, 
        pick random values for anomaly serie with the last 
        anomaly_duration * len(value_list) as upper bound, and substract these
        values to the normal serie.
        """
        
        # anomaly_duration is a ratio
        self.anomaly_index = self.timeserie.duration - self.anomaly_duration
        anomaly_indexes = list(range(self.anomaly_index, self.timeserie.duration))
        
        # randomly pick values for anomaly
        anomaly_cumsum = 0
        while anomaly_cumsum < self.an_weight_sum:

            value_index = np.random.choice(self.timeserie.duration - self.anomaly_index) + self.anomaly_index
            #an_value = np.random.choice(self.timeserie.serie[value_index])
            if self.timeserie.serie[value_index] > 0 :

                self.an_timeserie.serie[value_index] += 1 #an_value
                self.timeserie.serie[value_index] -= 1 #an_value
                anomaly_cumsum += 1

        self.logger.info('finished while')
        
        # shuffle remaining for "normality"
        self.timeserie.shuffle_timeserie(
                index_low = 0, index_high = self.anomaly_index)

        # generate regime shift by shuffling highest values
        np.random.shuffle(anomaly_indexes)
        self.timeserie.serie[self.anomaly_index:] = self.timeserie.serie[anomaly_indexes]
        self.an_timeserie.serie[self.anomaly_index:] = self.an_timeserie.serie[anomaly_indexes]

        #self.timeserie.shuffle_timeserie(
        #        index_low = self.anomaly_index, index_high = None)

    def _generate_peak(self):
        """ When anomaly type is 'peak', place anomaly at randomly picked
            index in timeserie
        """
        # put peak random place in timeserie, random index is at most equal to
        # anomaly index. 
        rdm_index = np.random.choice(self.anomaly_index)
        self.logger.debug('peak anomaly index {}'.format(rdm_index))
        normal_serie = np.concatenate([self.timeserie.serie[:rdm_index], 
                                       self.timeserie.serie[self.anomaly_index:], 
                                       self.timeserie.serie[rdm_index:self.anomaly_index]])
        an_serie = np.concatenate([self.an_timeserie.serie[:rdm_index], 
                                       self.an_timeserie.serie[self.anomaly_index:], 
                                       self.an_timeserie.serie[rdm_index:self.anomaly_index]])

        self.timeserie.serie = normal_serie
        self.an_timeserie.serie = an_serie

        return rdm_index

        #""" When anomaly type is peak, take the value_list sorted, 
        #use the last anomaly_duration * len(value_list) as the anomaly t_an,
        #shuffle it, and  use the first 
        #len(value_list) - anomaly_duration * len(value_list) as the 'normal'
        #t_n timeserie, and shuffle it independently.
        #Then pick a random index idx in the normal graph to place the peak.
        #The output timeserie is then 
        #  t_output = t_n[0:idx] + t_an + t[idx:]
        #where + designates the concatenation operator for lists.
        #"""
        ## anomaly index is duration of peak in samples
        #self.anomaly_index = int(self.timeserie.duration - self.anomaly_duration)

        ## randomly pick values for anomaly
        #for value_index in anomaly_indexes:
        #    an_value = np.random.choice(self.timeserie.serie[value])
        #    self.an_timeserie.serie[value_index] = an_value
        #    self.timeserie.serie[value_index] -= an_value

        ## get normal
        #self.timeserie.shuffle_timeserie(index_low = 0,
        #                                 index_high = self.anomaly_index)

        ## get peak
        #self.timeserie.shuffle_timeserie(index_low = self.anomaly_index, 
        #                                 index_high = None)

        ## put peak random place in timeserie, random index is at most equal to
        ## anomaly index. 
        #rdm_index = np.random.choice(self.anomaly_index)
        #self.logger.info('rdm index {}'.format(rdm_index))
        #global_serie = np.concatenate([self.timeserie.serie[:rdm_index], 
        #                               self.timeserie.serie[self.anomaly_index:], 
        #                               self.timeserie.serie[rdm_index:self.anomaly_index]])
        #self.timeserie.serie = global_serie
        #return rdm_index

    def run(self):
        self.logger.info('generating')
        self._generate_anomaly()
        #if self.anomaly_type == "regimeShift":
        #    # generate anomaly
        #    self._generate_regimeShift()
        if self.anomaly_type == "peak":
            self._generate_peak()
        elif self.anomaly_type == "regimeShift":
            # if regime shift use anomaly timeserie as is
            pass
        if self.plot:
            self.timeserie.plot()
        self.timeserie.write_TS()
        self.an_timeserie.write_TS()
