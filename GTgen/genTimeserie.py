"""
    Given a timeserie in input, generate a new, randomly picked,
    timeserie with the same values as the input timeserie, with an anomaly.
    The anomaly is generated by taking the highest values of the timeserie.
    Two types of anomalies:
        - Regime shift: use highest value, shuffled, to do a regime shift
                        at an index randomly picked idx. At idx, the mean
                        of the timeserie changes to a higher value.
        - Peak:         use a small number of the highest value, shuffled,
                        to create a peak randomly place in the timeserie.
    The complete process is:

    >>> - read input timeserie TS
    >>> - sort TS in increasing order
    >>> - Define index an_i such that the anomaly will contain the values
    >>>   of TS after an_i (highest values)
    >>> - shuffle TS[an_i:] to get 'anomaly'
    >>> - shuffle TS[:an_i] to get 'normality'
    >>> - if anomaly_type is peak:
    >>>     - pick random position pos < an_i
    >>>     - create TS` new timeserie with anomaly at pos such that:
    >>>        -TS`[pos:pos + (anomaly_duration)] = TS[an_i:]
    >>>        -TS`[:pos] + TS'[pos+(anomaly_duration):] = TS[:an_i] 
    >>>         (where + designates the concatenation of arrays)
"""

import time
import numpy as np
import matplotlib.pyplot as plt

from GTgen.timeserie import * 

class TimeserieWithAnomaly():
    """
         Attributes:
         -----------
         value_list: list of int,
            the timeserie taken as input
         anomaly_type: string, either 'regimeShift' or 'peak',
            if regimeShift, anomaly is a regimeShift, otherwise it is a peak
         anomaly_duration: float,
            the duration of the anomaly is anomaly_duration * len(value_list),
         output: string,
            path to the output file in which timeserie should be written
         logger: logger,
            a logger
         plot: bool,
            if True, plot the timeserie
    """
    def __init__(self, value_list,
            anomaly_type,
            anomaly_duration,
            output,
            logger,
            plot=False):
        #self.numberOfAnomaly = numberofAnomaly
        self.value_list = value_list
        self.anomaly_type = anomaly_type
        self.anomaly_duration = int(len(value_list) * anomaly_duration)
        self.anomaly_index = None

        self.timeserie = Timeserie(serie=np.array(value_list), out_path=output)

        # sort timeserie
        self.timeserie.serie = self.timeserie.sorted_timeserie
        self.logger = logger
        self.output = output

    def _generate_regimeShift(self):
        """ When anomaly type is regimeShift, take the value_list sorted, 
        use the last anomaly_duration * len(value_list) as the anomaly,
        shuffle it, and  use the first 
        len(value_list) - anomaly_duration * len(value_list) as the 'normal'
        timeserie, and shuffle it independently.
        Then the output timeserie is the concatenation of first the 'normal'
        timeserie then the 'anomaly'.
        """

        # anomaly_duration is a ratio
        self.anomaly_index = self.timeserie.duration - self.anomaly_duration
        # generate regime shift by shuffling highest values
        self.timeserie.shuffle_timeserie(
                index_low = self.anomaly_index, index_high = None)
        # shuffle remaining for "normality"
        self.timeserie.shuffle_timeserie(
                index_low = 0, index_high = self.anomaly_index)

    def _generate_peak(self):
        """ When anomaly type is peak, take the value_list sorted, 
        use the last anomaly_duration * len(value_list) as the anomaly t_an,
        shuffle it, and  use the first 
        len(value_list) - anomaly_duration * len(value_list) as the 'normal'
        t_n timeserie, and shuffle it independently.
        Then pick a random index idx in the normal graph to place the peak.
        The output timeserie is then 
          t_output = t_n[0:idx] + t_an + t[idx:]
        where + designates the concatenation operator for lists.
        """
        # anomaly index is duration of peak in samples
        self.anomaly_index = int(self.timeserie.duration - self.anomaly_duration)

        # get peak
        self.timeserie.shuffle_timeserie(index_low = self.anomaly_index, 
                                         index_high = None)

        # get normal
        self.timeserie.shuffle_timeserie(index_low = 0,

                                         index_high = self.anomaly_index)
        # put peak random place in timeserie, random index is at most equal to
        # anomaly index. 
        rdm_index = np.random.choice(self.anomaly_index)
        self.logger.info('rdm index {}'.format(rdm_index))
        global_serie = np.concatenate([self.timeserie.serie[:rdm_index], 
                                       self.timeserie.serie[self.anomaly_index:], 
                                       self.timeserie.serie[rdm_index:self.anomaly_index]])
        self.timeserie.serie = global_serie
        return rdm_index

    def run(self):
        self.logger.info('generating')
        if self.anomaly_type == "regimeShift":
            # generate anomaly
            self._generate_regimeShift()
        elif self.anomaly_type == "peak":
            self._generate_peak()
        if self.plot:
            self.timeserie.plot()
        self.timeserie.write_TS(self.output)
